<!-- ENTRY_ID: https://velog.io/@limseohyeon/%EC%A7%81%EB%A0%AC%ED%99%94%EC%99%80-%EC%97%AD%EC%A7%81%EB%A0%AC%ED%99%94-10%EB%B6%84-%ED%85%8C%EC%BD%94%ED%86%A1 -->
<!-- SOURCE_TITLE: 직렬화와 역직렬화 - 10분 테코톡 -->

<p><img alt="" src="https://velog.velcdn.com/images/limseohyeon/post/57ca0df9-4190-46b0-8f35-e5008a6e9781/image.png" />
<a href="https://youtu.be/8gyAr3lXGSw?si=X7WfJ1F1265gK8lf">10분 테코톡 - 직렬화와 역직렬화</a></p>
<h1 id="1-직렬화와-역직렬화">1. 직렬화와 역직렬화</h1>
<hr />
<h2 id="11-직렬화-serialization">1.1 직렬화 (Serialization)</h2>
<p>직렬화란 객체를 저장하거나 전송할 수 있는 상태로 변환하는 과정을 의미한다.</p>
<h2 id="12-역직렬화-deserialization">1.2 역직렬화 (Deserialization)</h2>
<p>역직렬화란 직렬화된 데이터를 다시 객체로 복원하는 과정을 의미한다.</p>
<h2 id="13-직렬화와-역직렬화를-왜-사용할까">1.3 직렬화와 역직렬화를 왜 사용할까?</h2>
<p>JVM의 데이터를 외부 시스템에 바로 전달하면 이해할 수 없다. 이에 외부 시스템도 이해할 수 있도록 바이트나 문자열 형식으로 변경하는 것이다.</p>
<hr />
<h1 id="2-spring-에서의-직렬화와-역직렬화">2. Spring 에서의 직렬화와 역직렬화</h1>
<hr />
<h2 id="21-requestbody-와-responsebody">2.1 @RequestBody 와 @ResponseBody</h2>
<p>Spring 에서 직렬화와 역직렬화를 지원해주는 애노테이션</p>
<ul>
<li>@RequestBody : HTTP 요청의 본문을 Java 객체로 변환 (역직렬화)</li>
<li>@ResponseBody : Java 객체를 HTTP 응답의 본문에 JSON 등으로 변환 (직렬화)</li>
</ul>
<h2 id="22-httpmessageconverter">2.2 HttpMessageConverter</h2>
<p>직렬화, 역직렬화 과정에서 사용하는 핵심 컴포넌트로 인터페이스로 존재한다. </p>
<p><strong>제공 메서드</strong></p>
<ul>
<li><code>canRead</code> : 역직렬화가 가능한지 확인</li>
<li><code>canWrite</code> : 직렬화가 가능한지 확인</li>
<li><code>read</code> : 역직렬화</li>
<li><code>write</code> : 직렬화</li>
</ul>
<h3 id="221-httpmessageconvert-종류">2.2.1 HttpMessageConvert 종류</h3>
<p>HttpMessageConver는 interface로 이에대한 구현체가 Spring에 내장되어 있다.</p>
<ul>
<li>ByteArrayHttpMessageConverter</li>
<li>StringHttpMessageConverter</li>
<li>MappingJackson2HttpMessageConverter</li>
</ul>
<p>이번엔 MappingJackson2HttpMessageConverter 위주로 알아보자.</p>
<h1 id="3-mappingjackson2httpmessageconverter">3. MappingJackson2HttpMessageConverter</h1>
<hr />
<h2 id="31-직렬화와-역직렬화-과정">3.1 직렬화와 역직렬화 과정</h2>
<h3 id="311-직렬화-과정"><strong>3.1.1 직렬화 과정</strong></h3>
<ol>
<li><strong>객체 탐색</strong> : <code>ObjectMapper</code>가 객체 타입을 확인함</li>
<li><strong>필드 접근 방식 결정</strong><ol>
<li>기본적으로 <code>Getter</code>을 기준으로함</li>
<li>그외에도 <code>@JsonProperty</code>/<code>@JsonIgnore</code> 를 참고해 구성</li>
</ol>
</li>
<li><strong>변환 후 JSON 문자열 생성</strong></li>
</ol>
<h3 id="312-역직렬화-과정"><strong>3.1.2 역직렬화 과정</strong></h3>
<ol>
<li><strong>기본 생성자 호출</strong><ol>
<li>기본적으로 기본 생성자를 기준으로 함</li>
<li>기본 생성자가 없는 경우 <code>@JsonCreator</code> 혹은 팩토리 메서드로 생성</li>
</ol>
</li>
<li><strong>Setter나 필드 주입으로 값 채우기</strong></li>
<li>커스텀 변환 처리 : <code>@JsonDeserialize</code>가 지정된 경우 이 로직 사용, 변환 완료 후 객체 반환</li>
</ol>
<p>아래에서 더 자세히 알아보도록 하자.</p>
<h2 id="32-objectmapper">3.2 ObjectMapper</h2>
<p>Java 객체를 Json또는 반대로 Json을 java 객체로 변경해주는 도구이다. MappingJackson2HttpMessageConverter에서는 ObjectMapper을 이용해 직렬화/역직렬화를 수행한다.</p>
<h2 id="33-직렬화와-역직렬화-조건">3.3 직렬화와 역직렬화 조건</h2>
<p>Jackson(즉, ObjectMapper)이 JSON ↔ 객체 직렬화/역직렬화를 수행할 때 기본적으로 아래와 같은 순서로 진행된다.</p>
<h3 id="331-직렬화-조건">3.3.1 직렬화 조건</h3>
<p>역직렬화와 마찬가지로 필드가 public을 사용하면 직접적으로 직렬화 가능하지만 private인 경우 get을 필요로 한다.</p>
<ul>
<li><p><strong>주의!</strong></p>
<p>  메서드명이 getXxx() 와같이 되어있으면 이를 직렬화할 객체로 인식하고 X를 소문자로 변경한 뒤 이를 필드명으로 사용한다.</p>
<p>  이때문에 개발자가 직렬화가 아닌 다른 용도로 사용할 목적의 메서드지만 getXXX 와 같은 형식을 띄고 있다면 의도치않은 직렬화가 발생할 수 있다. </p>
</li>
</ul>
<h3 id="332-역직렬화-조건">3.3.2 역직렬화 조건</h3>
<p>기본적으로 클래스에서 필드가 public을 사용하면 직접적으로 역직렬화 가능하지만private인 경우 set을 필요로 한다. </p>
<p>이에 Jackson에서 <strong>Reflection</strong>이라는 정보를 런타임에 동적으로 조회하고 조작할 수 있게 해주는 기능을 제공해 별도의 set 없이 기본 생성자만으로 역직렬화를  가능하게 한다.</p>
<h2 id="34-jackson의-애노테이션">3.4 Jackson의 애노테이션</h2>
<h3 id="341-jsonignore">3.4.1 @JsonIgnore</h3>
<p>직렬화/역직렬화 대상에서 제외시켜 보안이나 불필요한 데이터 전송을 막는다.</p>
<ul>
<li>메서드에 적용</li>
</ul>
<pre><code class="language-java">@JsonIgnore
public String getNameNumber(){
    return name + number
}</code></pre>
<ul>
<li>필드에 적용</li>
</ul>
<pre><code class="language-java">@JsonIgnore
private String name;
private Long number;</code></pre>
<h3 id="342-jsoncreator--jsonproperty">3.4.2 @JsonCreator + @JsonProperty</h3>
<ul>
<li><code>@JsonCreator</code> : 기본 생성자 없이 특정 생성자를 역직렬화에 사용할 생성자로 지정</li>
<li><code>@JsonProperty</code> : JSON 키 이름과 생성자의 파라미터를 매핑</li>
</ul>
<pre><code class="language-java">@JsonCreator
public Crew(@JsonProperty(&quot;name&quot;) Stirng name, @JsonProperty(&quot;number&quot;) Long number){
    this.name = name;
    this.number = number;
}</code></pre>
<p>@JsonCreator을 통해 역직렬화시 기본생성자가 없어도 되지만 @JsonProperty 생략 불가하다.</p>
<p>즉, JsonCreator + JsonProperty 조합을 통해 <strong>1. 기본 생성자 없이도 역직렬화가 가능</strong>하고, 어떤 <strong>2. 필드를 생성자에서 직접 지정</strong>해 역직렬화할지 개발자가 선택할 수 있다.</p>
<h3 id="343-직렬화-에서의-jsonpropery">3.4.3 직렬화 에서의 @JsonPropery</h3>
<p>@JsonPropery를 필드에 직접 사용하면 직렬화 과정에서 아래와 같은 기능을 한다.</p>
<ol>
<li>Getter 생략 가능</li>
<li>직렬화시 필드명 설정 가능</li>
</ol>
<pre><code class="language-java">@JsonProperty(&quot;myName&quot;)
private String name;</code></pre>
<h1 id="4-마무리">4. 마무리</h1>
<hr />
<p>오늘은 Json - Jackson 을 위주로 알아봤다. 하지만, Json을 직렬화/역직렬화 하는 라이브러리는 Jackson말고도 존재하며 Json말고도 다른 형식으로 변경해야하는 경우도 많다.</p>
<p>이에 다양한 방법을 폭 넓게 알아보면 좋을 것 같다.</p>
<p>실제 지난 프로젝트에서 Json과 XML 형식만 다루어 보았기 때문에 다른 형식은 잘 모른다… 날잡고 한 번 공부해봐야겠다.</p>
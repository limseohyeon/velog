<!-- ENTRY_ID: https://velog.io/@limseohyeon/%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84-%EA%B8%B0%EC%B4%881-12.-%EC%B1%84%ED%8C%85-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84 -->
<!-- SOURCE_TITLE: [가상 면접 사례로 배우는 대규모 시스템 설계 기초]  12. 채팅 시스템 설계 -->

<hr />
<h1 id="1-문제-이해">1. 문제 이해</h1>
<aside>

<ol>
<li>응답지연이 낮은 일대일 채팅</li>
<li>최대 100명까지 참여할 수 있는 그룹 채팅</li>
<li>사용자 접속 상태 표시</li>
<li>다양한 단말 지원, 하나의 계정으로 여러 단말 접속 가능</li>
<li>푸시 알림</li>
<li>일별 능동 사용자수(DAU: Daliy Active User) 기준 5천만명</aside>

</li>
</ol>
<h2 id="11-개략적-설계안">1.1 개략적 설계안</h2>
<p>무상태 서비스</p>
<ul>
<li>로그인, 회원가입 ,사용자 프로파일표시 등 전통적인 요청/응답 서비스</li>
</ul>
<p>상태 유지 서비스</p>
<ul>
<li>채팅 서비스</li>
<li>클라이언트는 서버가 살아있는 한 다른 서버로 연결을 변경하지 않는다.</li>
</ul>
<p>제3자 서비스 연동</p>
<ul>
<li>푸시 알림</li>
</ul>
<h1 id="2-클라이언트와-서버-통신-방법">2. 클라이언트와 서버 통신 방법</h1>
<p>서비스는 아래와 같은 역할을 수행한다.</p>
<ul>
<li>클라이언트는 서로 직접 통신하지 않는다.</li>
<li>클라이언트들로부터 메시지를 수신한다.</li>
<li>수신자를 결정 및 전달한다.</li>
<li>수신자가 접속 상태가 아닌 경우 접속할 때까지 해당 메시지를 보관한다.</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/limseohyeon/post/62c3aacd-9da2-4d43-83a8-0d805e308625/image.png" /></p>
<h2 id="21-송신-시나리오"><strong>2.1 송신 시나리오</strong></h2>
<ul>
<li>송신 클라이언트는 수신 클라이언트에 전달할 메시지를 채팅 서비스에 전달한다.</li>
<li>이때, 프로토콜을 사용하는데 현재 HTTP는 웹 서비스에서 가장 널리 사용되는 프로토콜이다.</li>
<li>채팅 서비스와의 접속에는 keep-alive 헤더를 사용한다.<ul>
<li>클라이언트 - 서버 연결 유지 가능</li>
<li>핸드셰이크 횟수 감소 가능</li>
</ul>
</li>
</ul>
<h2 id="22-수신-시나리오"><strong>2.2 수신 시나리오</strong></h2>
<p>HTTP는 클라이언트 → 서버 연결 시점에 사용하는 프로토콜로 서버→ 클라이언트 연결 시점에는 쉽게 사용할 수 없다.</p>
<p>이에 서버가 연결을 만들기 위해 폴링(polling), 롱 폴링(long poll-ing), 웹소켓(webSocket)등의 기술을 사용한다.</p>
<h3 id="폴링">폴링</h3>
<p>클라이언트가 주기적으로 서버에게 새 메시지 여부를 확인하는 방법이다.</p>
<ul>
<li>폴링 비용은 폴링을 자주 할수록 올라간다.</li>
<li>새 메시지가 없는 경우 서버 자원이 불필요하게 낭비 된다.</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/limseohyeon/post/37067e3f-9652-41a4-94c7-29bee646a289/image.png" /></p>
<h3 id="롱-폴링">롱 폴링</h3>
<p>클라이언트는 새 메시지가 반환되거나 타임아웃될 때 까지 연결을 유지한다.</p>
<p>단점</p>
<ul>
<li>로드밸런싱으로 인해 송신 - 수신 클라이언트가 같은 서버에 접속하지 않은 경우 메시지가 유실되거나 늦게 전달될 수 있다.</li>
<li>서버는 클라이언트가 연결을 해제했는지 알 수 없다.</li>
<li>폴링과 마찬가지로 주기적으로 서버에 접속하기 때문에 낭비가 발생한다.</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/limseohyeon/post/d8da64fd-623c-4eda-8c32-e4fb2ae23c9b/image.png" /></p>
<h3 id="웹-소켓">웹 소켓</h3>
<p>서버가 클라이언트에게 비동기 메시지를 보낼 때 가장 널리 사용하는 기술이다.</p>
<ul>
<li>클라이언트는 핸드셰이크 절차를 거쳐 HTTP → 웹소켓 연결로 변경한다.</li>
<li>연결은 항구적이며 양방향이다.</li>
<li>연결이 되면 서버는 클라이언트에게 비동기적으로 메시지를 전송할 수 있다.</li>
<li>웹소켓은 기본 포트번호를 그대로 사용하기 때문에 방화벽이 있는 환경에서도 잘 동작한다.</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/limseohyeon/post/e538eb1f-f752-4c53-a4b7-d7b95e40011e/image.png" /></p>
<h1 id="3-계략적-설계안">3. 계략적 설계안</h1>
<p><img alt="" src="https://velog.velcdn.com/images/limseohyeon/post/dbd01244-9f54-4c19-9567-11f845d5e15f/image.png" /></p>
<ul>
<li>채팅 서버 : 클라이언트 사이에서 메시지 중계 역할</li>
<li>접속상태 서버 : 사용자 접속 여부 관리</li>
<li>API 서버 : 채팅 외 나머지 전부 처리</li>
<li>알림 서버 : 푸시 알림 전송</li>
<li>키-값 저장소 : 채팅 이력 보관</li>
</ul>
<h2 id="31-무상태-서비스">3.1 무상태 서비스</h2>
<p>로그인, 회원가입, 사용자 프로파일 표시 등 전통적인 요청/응답 서비스로 무상태 서비스는 로드밸런서 뒤에 위치하며 로드밸런서는 요청을 경로에 맞는 서비스로 전달한다.</p>
<ul>
<li>서비스 탐색 서비스 : 클라이언트가 접속할 채팅 서버의 DNS 호스팅 명을 클라이언트에게 알리는 역할을 한다.</li>
</ul>
<h2 id="32-상태-유지-서비스">3.2 상태 유지 서비스</h2>
<p>채팅 서비스로 클라이언트는 서버가 살아 있는 한 다른 서버로 연결을 변경하지 않는다.</p>
<ul>
<li>서비스 탐색 서비스는 채팅 서비스와 협력해 특정 서버에 부하가 몰리지 않도록 한다.</li>
</ul>
<h2 id="33-제3자-서비스-연동">3.3 제3자 서비스 연동</h2>
<p>푸시 알람 서비스</p>
<h2 id="34-저장소">3.4 저장소</h2>
<p>데이터 계층을 올바르게 만들기 위해 데이터 유형과 읽기/쓰기 패턴에 따라 어떤 데이터베이스를 사용할지 결정해야 한다. 채팅 시스템은 보통 두 가지 데이터를 다룬다.</p>
<p><strong>일반적 데이터</strong></p>
<ul>
<li>사용자 프로파일, 설정 친구 목록 등…</li>
<li>관계형 데이터베이스를 통해 안정성을 보장한다.</li>
<li>다중화, 샤딩 등 사용</li>
</ul>
<p><strong>채팅 시스템 고유 데이터</strong></p>
<ul>
<li>채팅 이력 등…</li>
<li>특징<ul>
<li>방대한 양의 데이터</li>
<li>최근 주고 받은 메시지를 주로 사용하며 오래 될 수록 거의 사용하지 않는다.</li>
<li>언급, 검색 등 무작위적인 데이터 접근이 발생한다.</li>
<li>읽기:쓰기 비율은 대략 1:1 정도다.</li>
</ul>
</li>
<li>키-값 저장소 사용 추천<ul>
<li>수평적 규모확장 쉬움</li>
<li>데이터 접근 지연시간 낮음</li>
<li>관계형 데이터베이스는 lon tail을 다소 잘 처리하지 못함. 인덱스 커지면 무작위적 접근 비용 증가</li>
</ul>
</li>
</ul>
<h2 id="35-데이터-모델">3.5 데이터 모델</h2>
<h3 id="11-채팅을-위한-메시지-테이블">1:1 채팅을 위한 메시지 테이블</h3>
<p><img alt="" src="https://velog.velcdn.com/images/limseohyeon/post/4232d811-f9f2-42df-a285-775c0cf25a17/image.png" /></p>
<p>messsage_id 는 기본 키 이자 메시지 순서 지정 역할을 담당한다. created_ate을 사용하지 않는 이유는 두 메시지가 동시에 만들어 질 수도 있기 때문이다.</p>
<h3 id="그룹-채팅을-위한-메시지-테이블">그룹 채팅을 위한 메시지 테이블</h3>
<p><img alt="" src="https://velog.velcdn.com/images/limseohyeon/post/40efe7ef-03db-4de4-bc4a-be61713e9d2b/image.png" /></p>
<p>channel_id, message_id의 복합키를 기본 키로 사용한다.</p>
<h3 id="메시지id">메시지ID</h3>
<p>message_id의 값은 아래와 같은 속성을 만족해야 한다.</p>
<ul>
<li>고유해야 한다.</li>
<li>정렬 가능해야 하며, 시간 순서와 일치해야 한다.</li>
</ul>
<p>두 조건을 어떻게 만족할 수 있을까?</p>
<ul>
<li>auto_increment : RDBMS에서는 사용할 수 있으나 NpSQL에서는 사용할 수 없다.</li>
<li>스노플레이크 : 전역적 64-bit 순서 번호 생성기</li>
<li>지역적 순서 번호 생성기 : ID의 유일성은 같은 그룹 안에서만(채팅 채널, 같은 1:1 채팅 세션) 보증된다.</li>
</ul>
<h1 id="4-상세-설계">4. 상세 설계</h1>
<hr />
<p>위에서 본 내용 중 몇 가지 컴포넌트를 자세히 보도록 하자.</p>
<h2 id="41-서비스-탐색">4.1 서비스 탐색</h2>
<p><img alt="" src="https://velog.velcdn.com/images/limseohyeon/post/8180645f-1720-47ef-add5-0c955ea7050f/image.png" /></p>
<p>서비스 탐색의 주된 역할은 클라이언트에게 가장 적합한 채팅 서버를 추천하는 것이다.</p>
<ol>
<li>사용 가능한 채팅 서버 등록</li>
<li>클라이언트 접속 시도시 기준에 따라 최적읜 채팅 서버 매칭</li>
</ol>
<h2 id="42-메시지-흐름">4.2 메시지 흐름</h2>
<h3 id="11-채팅">1:1 채팅</h3>
<p><img alt="" src="https://velog.velcdn.com/images/limseohyeon/post/85d2fe81-922b-4b56-9a60-16b4e34ebf09/image.png" /></p>
<ol>
<li>사용자 A → 서버1 메시지 전송</li>
<li>서버1의 ID 생성기로 메시지 ID 결정</li>
<li>서버1 → 메시지 동기화 큐로 메시지 전송</li>
<li>메시지 키-값 저장소 보관</li>
<li>사용자 B 접속 O<ol>
<li>사용자 B 접속중인 채팅 서버(이하 서버2)로 메시지 전송</li>
</ol>
</li>
<li>사용자 B 접속 X<ol>
<li>푸시 알림 메시지를 푸시 알림 서버로 전송</li>
</ol>
</li>
<li>서버2 - 사용자 B 사이 웹소켓 연결 상태로 메시지 전송</li>
</ol>
<h3 id="여러-단말-사이의-메시지-동기화">여러 단말 사이의 메시지 동기화</h3>
<p><img alt="" src="https://velog.velcdn.com/images/limseohyeon/post/554662d9-8878-4a52-8a62-6ac40744fb72/image.png" /></p>
<ul>
<li>두 단말은 같은 서버에 접속</li>
<li>cur_max_message_id : 각 단말 최신 메시지 ID 추적, 이를 통해 동기화 작업 구현 가능</li>
</ul>
<h3 id="소규모-그룹-채팅">소규모 그룹 채팅</h3>
<p><img alt="" src="https://velog.velcdn.com/images/limseohyeon/post/a3b1403f-3ee4-4517-b011-cfa0045486a1/image.png" /></p>
<ol>
<li>사용자 A 그룹 채팅방에 메시지 전송</li>
<li>사용자 B, C 메시지 동기화 큐에 메시지 복사</li>
</ol>
<p>메시지 동기화 큐는 소규모 그룹 채팅에 적합하다. 이유는 아래와 같다.</p>
<ul>
<li>자기 큐만 확인하면 되기 때문에 동기화 플로 단순</li>
<li>그룹이 작으면 큐에 넣는 작업 비용이 문제되지 않는다.</li>
</ul>
<h2 id="43-접속-상태-표시">4.3 접속 상태 표시</h2>
<p>사용자 상태가 바뀌는 시나리오는 몇 가지가 존재한다.</p>
<h3 id="사용자-로그인">사용자 로그인</h3>
<ol>
<li>웹소켓 연결</li>
<li>사용자 상태와 last_active_at 타임스탬프 값 키-값 저장소에 보관</li>
<li>사용자 접속 중 표시</li>
</ol>
<h3 id="사용자-로그아웃">사용자 로그아웃</h3>
<ol>
<li>사용자 로그아웃</li>
<li>API 서버 → 접속상태 서버에 전송</li>
<li>키-값 저장소 status : offline 변경</li>
</ol>
<h3 id="접속-장애">접속 장애</h3>
<p>일시적인 상태 접속에 따라 사용자의 상태를 변경하는 것은 좋지 못한 솔루션이다. 이에 박동(heartbeat)검사를 이용해 해당 문제를 해결한다.</p>
<ol>
<li>주기적으로 박동 이벤트를 접속상태 서버로 전송</li>
<li>마지막 이벤트 받은 후 x초 이내 이벤트 메시지 수신 하면 접속상태 온라인, 그렇지 않으면 오프라인</li>
</ol>
<h3 id="상태-정보-전송">상태 정보 전송</h3>
<p>해당 사용자의 상태 변경을 다른 사용자는 어떻게 알 수 있을까?</p>
<p><strong>발행-구독 모델</strong></p>
<p>각각의 친구 관계마다 채널을 하나씩 둔다.</p>
<ol>
<li>A 접속상태 변경</li>
<li>변경 사항을 A-B, A-C, A-D에 쓴다. B, C, D는 채널 A를 구독한다.</li>
</ol>
<p>발행-구독 모델은 소규모에 적합하다. 그룹 크기가 커지면 사용자가 그룹 채팅에 입장하는 순간에만 상태 정보를 읽거나, 수동으로 하도록 유도하도록 한다.</p>
<h1 id="5-더-고려해볼-것">5. 더 고려해볼 것</h1>
<ul>
<li>미디어 지원을 통한 채팅앱 확장</li>
<li>메시지 전송 종단간 암호화</li>
<li>캐시</li>
<li>로딩 속도 개선</li>
<li>오류 처리<ul>
<li>채팅 서버 오류</li>
<li>메시지 재전송</li>
</ul>
</li>
</ul>
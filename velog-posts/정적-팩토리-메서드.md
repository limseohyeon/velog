<!-- ENTRY_ID: https://velog.io/@limseohyeon/%EC%A0%95%EC%A0%81-%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C -->
<!-- SOURCE_TITLE: 정적 팩토리 메서드 -->

<h1 id="0-개요">0. 개요</h1>
<hr />
<p>‘정적 팩토리 메서드’ 라는 말은 많이 들었는데, 정작 그게 뭔지 어떤 역할을 하는지 모르고 있다는 것을 알았다. 이에 오늘은 정적 팩토리 메서드에 대해 알아보고자 한다.</p>
<p>(추상 팩토리, 팩토리 메서드에 묻혀 대강 이쪽이라고 생각하며 살았던듯…)</p>
<h1 id="1-정적-팩토리-메서드란">1. 정적 팩토리 메서드란?</h1>
<hr />
<p>Static Method를 통해 간접적으로 생성자 호출을 담당하는 객체 생성 디자인 패턴이다. 쉽게 말하면, 객체의 생성을 담당하는 클래스 메서드다.</p>
<p>일반적으로 객체를 생성할 때 new 키워드를 통해 생성자로 직접 인스턴스화하는데 이를 클래스 메서드를 통해 간접적으로 유도하는 것이다.</p>
<pre><code class="language-java">class Book {
    private String title;

    // 생성자를 private화 하여 외부에서 생성자 호출 차단
    private Book(String title) { this.title = title; }

    // 정적 팩토리 메서드
    public static Book titleOf(String title) {
        return new Book(title); // 메서드에서 생성자를 호출하고 리턴함
    }
}</code></pre>
<h2 id="11-정적-팩토리-특징">1.1 정적 팩토리 특징</h2>
<p>하나의 생성자에서 인스턴스를 만들면 될 텐데… 왜 굳이? 정적 팩토리를 만들어 사용할까?</p>
<h3 id="111-생성-목적에-대한-이름-표현이-가능하다">1.1.1 생성 목적에 대한 이름 표현이 가능하다.</h3>
<p><strong>&lt;변경 전&gt;</strong></p>
<pre><code class="language-java">class Car {
    private String brand;
    private String color = &quot;black&quot;;

    public Car(String brand, String color) {
        this.brand = brand;
        this.color = color;
    }

    public Car(String brand) {
        this.brand = brand;
    }
}</code></pre>
<p>생성시 brand는 필수로 입력을 받아야 하지만 color은 default balck로 선택적으로 받을 수 있다.</p>
<p>Car 생성 방식을 오버로딩으로 처리하고, 개발자는 인자 개수를 보고 어떤 생성자인지 판단해야한다.</p>
<p>가장 기본이 되는 방식이지만 이는 반환 될 객체의 특성을 제대로 표현하지 못하기 때문에 이는 읽기 어려운 코드이기도 하다. (개발자가 나 혼자라면 괜찮겠지만 팀원이 존재한다면 어떤 new Car가 어떤 역할을 수행하는지 파악하기 어려워 질 것이다.)</p>
<p><strong>&lt;변경 후&gt;</strong></p>
<pre><code class="language-java">class Car {
    private String brand;
    private String color;

    // private 생성자
    private Car(String brand, String color) {
        this.brand = brand;
        this.color = color;
    }

    // 정적 팩토리 메서드 (매개변수 하나는 from 네이밍)
    public static Car brandBlackFrom(String brand) {
        return new Car(brand, &quot;black&quot;);
    }

    // 정적 팩토리 메서드 (매개변수 여러개는 of 네이밍)
    public static Car brandColorOf(String brand, String color) {
        return new Car(brand, color);
    }
}</code></pre>
<ul>
<li>주의!: 정적 팩토리 메서드를 구성한다면 반드시 생성자에 private 제어 외부에서 접근하지 못 하도록 막아야 한다.</li>
</ul>
<h3 id="112-인스턴스에-대해-통제-및-관리가-가능하다">1.1.2 인스턴스에 대해 통제 및 관리가 가능하다.</h3>
<p>메서드를 통해 한 단계 거쳐 객체를 생성하기 때문에 전반적인 객체 생성 및 통제 관리를 할 수 있게 된다.</p>
<p>대표적인 예로 Singleton 디자인 패턴, 캐싱이 있다.</p>
<pre><code class="language-java">class Singleton {
    private static Singleton instance;

    private Singleton() {}

    // 정적 팩토리 메서드
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}</code></pre>
<p>아래와 같이 인자에 따라 인스턴스를 결정할 수도 있다.</p>
<pre><code class="language-java">interface SmarPhone {
    public static SmarPhone getPhone(int price) {
        if(price &gt; 100000) {
            return new IPhone();
        }

        if(price &gt; 50000) {
            return new Galaxy();
        }

        return new Huawei();
    }
}</code></pre>
<h3 id="113-하위-자료형-객체를-반환할-수-있다">1.1.3 하위 자료형 객체를 반환할 수 있다.</h3>
<p>클래스의 다형성의 특징을 응용한 방법이다. 메서드 호출을 통해 얻을 객체의 인스턴스 선택의 유연성이 생기는 것이다.</p>
<pre><code class="language-java">interface SmarPhone {}

class Galaxy implements SmarPhone {}
class IPhone implements SmarPhone {}
class Huawei implements SmarPhone {}

class SmartPhones {
    public static SmarPhone getSamsungPhone() {
        return new Galaxy();
    }

    public static SmarPhone getApplePhone() {
        return new IPhone();
    }

    public static SmarPhone getChinesePhone() {
        return new Huawei();
    }
}</code></pre>
<h3 id="114-객체-생성을-캡슐화-할-수-있다">1.1.4 객체 생성을 캡슐화 할 수 있다.</h3>
<p>1.1.3의 확장으로 구현부를 외부로 부터 숨기기 때문에 캡슐화, 정보 은닉을 할 수 있다는 특징이 있다. 또한, 의존성을 제거해주는 장점도 있다.</p>
<h2 id="12-정적-팩토리-메서드-네이밍-규칙">1.2 정적 팩토리 메서드 네이밍 규칙</h2>
<p>정적 팩토리 메서드와 다른 정적 메서드를 구분하기 위해 독자적인 네이밍 컨벤션이 존재한다.</p>
<ul>
<li>from : 하나의 매개 변수를 받아서 객체를 생성</li>
<li>of : 여러개의 매개 변수를 받아서 객체를 생성</li>
<li>getInstance | instance : 인스턴스를 생성. 이전에 반환했던 것과 같을 수 있음</li>
<li>newInstance | create : 항상 새로운 인스턴스를 생성</li>
<li>get[OrderType] : 다른 타입의 인스턴스를 생성. 이전에 반환했던 것과 같을 수 있음</li>
<li>new[OrderType] : 항상 다른 타입의 새로운 인스턴스를 생성</li>
</ul>
<h2 id="13-정적-팩토리-메서드-문제점">1.3 정적 팩토리 메서드 문제점</h2>
<p>생성자보단 정적 팩토리 메서드를 고려해야 하지만, 정적 팩토리 메서드도 단점이 있다. 이를 고려하고 사용해야 한다.</p>
<h3 id="131-private-생성자일-경우-상속-불가능">1.3.1 private 생성자일 경우 상속 불가능</h3>
<p>정적 팩토리 메서드를 사용하면 생성자를 private 접근 제어자로 설정하기 되기 때문에 팩토리 메서드를 적용하는 경우 상속을 이용한 확장이 불가능하다.</p>
<p>(그러나 이는 단점이라기 보단 합성을 사용하도록 유도하거나, 불변 객체로 만들고 싶을 때 사용하는 코드 패턴이라고 보면 된다.)</p>
<h3 id="132-api-문서에서-불편함">1.3.2 API 문서에서 불편함</h3>
<p>생성자는 문서화 경우 상단에 정의되지만 정적 팩토리 메서드는 메서드란에서 직접 찾아야 한다. 이에 문서를 잘 작성하거나(ㅋㅋ) 네이밍 컨벤션을 잘 지켜야 한다.</p>
<h1 id="2-마무리">2. 마무리</h1>
<hr />
<p>정적 팩토리 메서드를 처음 접했다고 생각했는데, 공부하다 보니 그동안 Entitiy에에서 <code>createMember()</code> 완 같은 메서드 내부에서 Builder를 통해 인스턴스를 생성해 왔는데 이게 이 개념을 따르고 있었다는 걸 깨달았다. 개념을 알고 나니 무의식적으로 사용하던 패턴의 의도를 명확히 이해할 수 있었고, 앞으로는 이런 설계 의도를 더 의식적으로 고려하고 싶다.</p>
<h1 id="참고">참고</h1>
<hr />
<p><a href="https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-%EC%A0%95%EC%A0%81-%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%83%9D%EC%84%B1%EC%9E%90-%EB%8C%80%EC%8B%A0-%EC%82%AC%EC%9A%A9%ED%95%98%EC%9E%90">💠 정적 팩토리 메서드 패턴 (Static Factory Method)</a></p>
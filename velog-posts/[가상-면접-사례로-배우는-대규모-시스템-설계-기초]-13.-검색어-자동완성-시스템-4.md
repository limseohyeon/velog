<!-- ENTRY_ID: https://velog.io/@limseohyeon/%EA%B0%80%EC%83%81-%EB%A9%B4%EC%A0%91-%EC%82%AC%EB%A1%80%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84-%EA%B8%B0%EC%B4%88-13.-%EA%B2%80%EC%83%89%EC%96%B4-%EC%9E%90%EB%8F%99%EC%99%84%EC%84%B1-%EC%8B%9C%EC%8A%A4%ED%85%9C -->
<!-- SOURCE_TITLE: [가상 면접 사례로 배우는 대규모 시스템 설계 기초] 13. 검색어 자동완성 시스템 -->

<h1 id="1-문제-이해">1. 문제 이해</h1>
<aside>

<ol>
<li>사용자 입력 단어의 첫 부분을 기준으로 자동완성이 수행된다.</li>
<li>5개의 자동완성 검색어가 표시된다.</li>
<li>검색어 인기 순위 기준으로 정렬된다.</li>
<li>모든 질의는 영어 소문자로 이루어진다. (그러나 다국어 지원을 생각해도 좋음)</li>
<li>월간 능동 사용자(DAU)기준 천만명</li>
<li>응답속도는 100밀리초 이내여야 한다.</li>
<li>많은 트래픽을 감당할 수 있도록 확장 가능해야 한다.</li>
<li>장애가 발생해도 시스템은 계속 사용 가능해야 한다.</aside>

</li>
</ol>
<h1 id="2-계략적-설계안">2. 계략적 설계안</h1>
<p><strong>데이터 수집 서비스</strong></p>
<p>사용자가 입력한 질의를 실시간으로 수집하는 시스템이다.</p>
<p><img alt="" src="https://velog.velcdn.com/images/limseohyeon/post/2cc651a7-6e87-4fa9-bd2a-f9baac160f38/image.png" /></p>
<ul>
<li>검색어와 빈도에 따라 테이블을 변경한다.</li>
</ul>
<p><strong>질의 서비스</strong></p>
<p>다섯 개의 인기 검색어를 정렬해 반환하는 서비스이다.</p>
<pre><code class="language-java">SELECT * FROM frequency_table
WHERE query Like `prefix%`
ORDER BY frequency DESC
LIMIT 5;</code></pre>
<ul>
<li>수집 서비스를 통해 생성한 빈도 테이블에서 위와 같은 쿼리를 통해 “top 5” 자동완성 검색어를 조회한다.</li>
</ul>
<p>그러나 이러한 방법은 데이터양이 증가하는 경우 데이터베이스 병목이 발생할 수 있다. 상세 설계안을 준비하며 해당 문제를 해결할 방법을 알아볼 것이다.</p>
<h1 id="3-상세-설계">3. 상세 설계</h1>
<hr />
<p>데이터 수집 서비스, 질의 서비스와 함께 컴포넌트 몇 개에 대해 상세히 설계해보자.</p>
<h2 id="31-트라이-자료구조">3.1 트라이 자료구조</h2>
<p>관계형 데이터베이스를 이용해  “top5” 질의문을 골라내는 방안은 효율적이지 않다.</p>
<p>이에 사용하는 것이 트라이 자료구조로 문자열들을 간략하게 저장할 수 있고, 문자열을 꺼내는 연산에 초점을 맞추어 설계되었다.</p>
<h3 id="특징"><strong>특징</strong></h3>
<ul>
<li>트리 형태의 자료구조이다.</li>
<li>루트 노드는 빈 문자열이다.</li>
<li>각 노드는 글자 하나를 저장하며 26개(해당 글자 다음에 등장할 수 있는 모든 글자 개수)의 자식노드를 가질 수 있다.</li>
<li>각 노드는 단어, 접두어 문자열을 나타낸다.</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/limseohyeon/post/a112270a-f6ed-4441-9daa-b001da8f3f09/image.png" /></p>
<h3 id="트라이-구조를-통한-자동-완성-구현-방법">트라이 구조를 통한 자동 완성 구현 방법</h3>
<p>k=2, 검색어 = ”be”일때 가장 많이 사용된 질의어를 찾아보자. </p>
<p>k(자동완성 질의어 개수), p(접두어 길이),  n (트라이 안에 있는 노드 개수), c (주어진 노드의 자식 노드 개수)</p>
<ol>
<li><strong>해당 접두어 표현 노드 탐색 O(p)</strong> : 접두어 “be” 노드를 찾는다.</li>
<li><strong>해당 노드 기준 유효한 하위 트리 탐색 O(c)</strong> : [beer:10], [best:35]. [bet:29]가 유효 노드다.</li>
<li><strong>유효 노드 정렬을 통해 검색어 k개 반환O(clogc)</strong> : 정렬후 2개를 반환한다. [best:35]. [bet:29]</li>
</ol>
<p>알고리즘의 시간 복잡도는 각 단계 소요시간 합인 O(p) + O(c) + O(clogc)가 된다. 그러나 최악의 경우 전체 트라이를 다 검색해야하는 일이 발생할 수 있다. </p>
<h3 id="자동-완성-구현-보완하기">자동 완성 구현 보완하기</h3>
<p><strong>접두어의 최대 길이 제한</strong></p>
<p>검색어 최대 길이를 제한하면 O(p) → O(작은 상수 값) = O(1) 까지 줄일 수 있다.</p>
<p><strong>각 노드 인기 검색어 캐시</strong></p>
<p>인기 검색어를 저장해두면 질의 시간 복잡도를 엄청나게 줄일수 있다. 물론 저장 공간이 필요하다는 단점이 있지만 응답속도를 위해 희생할만한 값이다.</p>
<hr />
<h2 id="32-데이터-수집-서비스">3.2 데이터 수집 서비스</h2>
<p>경우에 따라 트라이는 실시간으로 갱신할 필요가 없다. 트라이가 한 번 만들어지고 나면 인기 검색어는 그리 자주 바뀌지 않기 때문에 오히려 불필요하게 갱신할 경우 질의 서비스 속도 저하가 발생할 수 있다.</p>
<p>트라이를 만들기 위한 데이터는 주로 데이터 분석 서비스나 로깅 서비스를 이용해 수집하기 때문에 실시간 애플리케이션은 검색어를 신선하게 유지하고, 그렇지 않은 검색 애플리케이션은 자주 바꾸지 않는 등 용래에 따라 서비스를 설계하면 된다.
<img alt="" src="https://velog.velcdn.com/images/limseohyeon/post/cc0b5bf5-63f9-4f17-abb9-e02dbe0d52b7/image.png" /></p>
<h3 id="데이터-분석-서비스-로그">데이터 분석 서비스 로그</h3>
<p>검색장에 입력된 질의 원본 데이터를 보관한다.</p>
<ul>
<li>쓰기만 할 뿐 수정은 이루어지지 않는다.</li>
<li>인덱스를 걸지 않는다.</li>
</ul>
<h3 id="로그-취합-서버">로그 취합 서버</h3>
<p>데이터 분석 서비스의 로그를 잘 취합해 쉽게 소비할 수 있도록 한다.</p>
<p>실시간 애플리케이션은 취합 주기를 짧게, 그외 보통은 일주일 정도의 기간정도면 충분하다.</p>
<h3 id="취합된-데이터">취합된 데이터</h3>
<p><img alt="" src="https://velog.velcdn.com/images/limseohyeon/post/24a6d787-1039-423b-bbd6-26bde38b7ac4/image.png" /></p>
<h3 id="작업-서버">작업 서버</h3>
<p>주기적으로 비동기 작업(job)을 실행해 트라이 자료구조를 만들고 트라이 데이터베이스에 저장한다.</p>
<h3 id="트라이-캐시">트라이 캐시</h3>
<p>트라이 데이터베이스의 스냅샷을 떠 연산 성능을 높인다.</p>
<h3 id="트라이-데이터베이스">트라이 데이터베이스</h3>
<p>트라이 데이터베이스로 사용할 수 있는 선택지는 두가지가 존재한다.</p>
<ol>
<li><p>문서 저장소 : 주기적으로 트라이를 직렬화해 데이터베이스에 저장할 수 있다. ex) 몽고DB</p>
</li>
<li><p>키-값 저장소 : 변경 로직을 통해 해시 테이블 형태로 변환 할 수 있다.</p>
<p> 2-1. 접두어를 해시 테이블 키로 변환</p>
<p> 2-2. 드라이 노드 값을 해시 테이블 값으로 변환</p>
</li>
</ol>
<p><img alt="" src="https://velog.velcdn.com/images/limseohyeon/post/2ff2b168-4c0d-4abf-9354-721a3cd313ff/image.png" /></p>
<hr />
<h2 id="33-질의-서비스">3.3 질의 서비스</h2>
<p>질의 서비스는 아래와 같은 구조로 동작한다.</p>
<p><img alt="" src="https://velog.velcdn.com/images/limseohyeon/post/af552c59-f053-4b3f-9318-44b0f97f4062/image.png" /></p>
<ol>
<li>검색 질의 로드밸런서로 전송</li>
<li>로드밸런서 → API 서버로 검색질의 전달</li>
<li>API 서버는 트라이 캐시에서 자동완성 검색어 데이터 조회<ol>
<li>miss 발생시 DB에서 데이터를 가져온 후 캐시에 저장한다. 캐시 미스는 캐시 서버 메모리가 부족하거나 장애가 발생해도 발생할 수 있다.</li>
</ol>
</li>
</ol>
<p><strong>질의 서비스 보완하기</strong></p>
<ul>
<li>AJAX 요청 : AJAX요청을 통해 페이지 새로고침을 할 필요 없도록 한다.</li>
<li>브라우저 캐싱 : 검색어 결과는 짧은 시간안에 자주 바뀌지 않기 때문에 브라우저 캐시에 저장하도록 한다.</li>
<li>데이터 샘플링 : 대규모 시스템의 경우 모든 질의 결과를 로깅하면 자원을 엄청 소진한다. N개의 요청 가운데 1개만 로깅한다.</li>
</ul>
<h2 id="34-트라이-연산">3.4 트라이 연산</h2>
<h3 id="트라이-생성">트라이 생성</h3>
<p>작업 서버가 담당하며 데이터 분석 서비스의 로그나 데이터베이스로부터 취합된 데이터를 사용한다.</p>
<h3 id="트라이-갱신">트라이 갱신</h3>
<p>두 가지 방법이 존재한다.</p>
<ol>
<li>매주 한 번 새로운 트라이를 만들고 기존 트라이를 대체 한다.</li>
<li>트라이 각 노드를 개별적으로 갱신한다. (성능이 좋지 않기 때문에 트라이가 작은 경우에 고려)</li>
</ol>
<h3 id="검색어-삭제">검색어 삭제</h3>
<p>욕설, 혐도성 등 경우에 따라 트라이 캐시 앞에 필터 계층을 두어 부적절한 질의가 반환되지 않도록 한다.</p>
<p>해당 검색어를 데이터베이스에 물리적으로 삭제하는 것은 다음 업데이트 사이클에서 진행하면 된다.</p>
<h2 id="35-저장소-규모-확장">3.5 저장소 규모 확장</h2>
<p>현재 시스템은 영어만 지원하기 때문에 간단하게는 <strong>(1)첫 글자를 기준으로 샤딩</strong>하는 방법을 생각해 볼 수 있다.</p>
<ul>
<li>ex) 저장소1 ( ‘a’ ~ ’ m’), 저장소2 (나머지)</li>
<li>사용 가능한 서버는 최대 26대(알파벳 개수)로 제한된다.</li>
</ul>
<p>이 이상 서버를 늘리려면 <strong>(2)샤딩을 계층적</strong>으로 해야 한다. 그러나 해당 방법은 경우에 수가 너무 많기 때문에 데이터를 각 서버에 균등하게 배분하기 어렵다.</p>
<ul>
<li>ex) ‘a’로 시작하는 검색어를 4대의 샤딩으로 분리하기 : 저장소1 (’aa’ ~ ‘ag’), 저장소2 (’ah’ ~ ‘an’) … 생략</li>
</ul>
<p>이러한 문제를 해결하기 위해 <strong>(3)과거 질의 데이터 패턴 분석으로 샤딩</strong>하는 방법이 있다. 이는 검색어 대응 샤드 관리자가 수행한다.</p>
<ul>
<li>ex) ‘s’에 해당하는 검색어 양이 ‘u’, ‘v’, ‘z’ 검색어를 합친것과 비슷한 경우 : 저장소1(’s’), 저장소2(’u’, ‘v’, ‘z’)</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/limseohyeon/post/50636b4c-242e-497a-96a9-2e0d7af9aac8/image.png" /></p>
<h1 id="4-추가">4. 추가</h1>
<hr />
<ol>
<li><p><strong>다국어 지원이 가능하도록 시스템을 확장하려면 어떻게 해야 할까?</strong></p>
<p> ⇒ 트라이에 유니코드 데이터를 저장한다.</p>
</li>
<li><p><strong>국가별로 인기 검색어 순위가 다르면 어떻게 해야 할까?</strong></p>
<p> ⇒ 국가별로 다른 트라이를 사용하도록 한다.</p>
</li>
<li><p><strong>실시간 검색어 추이를 반영하려면 어떻게 해야 할까?</strong></p>
<p> ⇒ 위 책에서는 다루지 않는다. (앞선 설계는 트라이 갱신 주기, 트라이 구성시 많은 시간 소요와 같은 이유로 적합하지 않음) 그러나 몇 가지 고려할 수 있는 사항이 있다.</p>
<ul>
<li>샤딩을 통해 데이터양 줄이기</li>
<li>최근 검색어에 가중치 두기</li>
<li>데이터 스트리밍 = 데이터가 스트림 형태로 올 수 있기 때문에 한 번에 모든 데이터를 사용할 수 없을 가능성이 있음</li>
</ul>
</li>
</ol>
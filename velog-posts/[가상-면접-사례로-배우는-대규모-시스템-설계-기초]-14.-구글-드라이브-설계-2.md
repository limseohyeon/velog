<h1 id="15장-구글-드라이브-설계">15장 구글 드라이브 설계</h1>
<hr />
<h1 id="1-문제-이해">1. 문제 이해</h1>
<aside>

<ol>
<li>파일 업로드/다운로드, 파일 동기화, 알림 기능 제공</li>
<li>모바일 웹/앱 기기 지원</li>
<li>파일 암호화</li>
<li>파일은 10GB로 제한</li>
<li>DAU기준 천만</aside>

</li>
</ol>
<h1 id="2-계략적인-설계">2. 계략적인 설계</h1>
<hr />
<p><strong>API</strong></p>
<ol>
<li>파일 업로드 API<ol>
<li>단순 업로드 : 파일 크기가 작은 경우</li>
<li>이어 올리기 : 파일 사이즈가 커 네트워크 문제가 발생할 수 있는 경우<ol>
<li>이어올리기 URL 요청</li>
<li>데이터 업로드 후 상태 모니터링</li>
<li>장애 발생시 장애 시점부터 업로드 재시작</li>
</ol>
</li>
</ol>
</li>
<li>파일 다운로드 API</li>
<li>파일 갱신 히스토리 API</li>
</ol>
<p><strong>한 대 서버의 제약 극복</strong></p>
<ol>
<li>샤딩 : 여러 서버에 나누어 저장</li>
<li>S3 : 아마존의 업계 최고 수준의 규모 확장성, 가용성, 보안, 성능을 제공하는 객체 저장소 서비스. 같은 지역 혹은 여러 지역에 걸쳐  다중화 가능하다.</li>
</ol>
<p><strong>동기화 충돌</strong></p>
<p>두 명 이상의 사용자가 같은 파일이나 폴더를 동시에 업로드하려고 하는 경우 발생하는 현상이다.</p>
<ul>
<li>사용자 1과 사용자 2 파일에 동기화  충돌이 발생</li>
<li>시스템이 사용자1의 파일을 먼저 처리</li>
<li>로컬 사본과 서버에 있는 최신 버전 즉, 두 가지 버전의 파일이 존재하게 됨</li>
</ul>
<p>⇒ 두 파일을 합칠지 아니면 둘 중 하나를 다른 파일로 대체할지 결정해야 한다.</p>
<p><img alt="" src="https://velog.velcdn.com/images/limseohyeon/post/4059a82d-35e7-48d8-be71-db7dc2a9fc83/image.png" /></p>
<ul>
<li><strong>사용자 단말</strong> : 웹/앱 클라이언트</li>
<li><strong>블록 저장소 서버</strong> : 데이터 파일을 여러 개 블록으로 나누어 저장<ul>
<li>각 블록에는 해시 값이 할당되며 해시 정보는 메타데이터 데이터베이스에 저장</li>
<li>블록은 클라우드 저장소 시스템(S3)에 저장</li>
</ul>
</li>
<li><strong>클라우드 저장소</strong> : 블록 저장</li>
<li><strong>아카이빙 저장소</strong> : 비활성 데이터 저장</li>
<li><strong>로드밸런서</strong> : API 요청 분산</li>
<li><strong>API서버</strong> : 파일 업로드 외의 모든 기능 수행</li>
<li><strong>메타데이터 데이터베이스</strong> : 사용자, 파일, 블록, 버전 등의 메타데이터 정보</li>
<li><strong>메타데이터 캐시</strong> : 자주 쓰이는 메타데이터</li>
<li><strong>알림 서비스</strong></li>
<li><strong>오프라인 사용자 백업 큐</strong> : 클라이언트가 최신 상태를 확인할 수 없을 때 해당 정보를 큐에 두어 사용자 접속시 동기화</li>
</ul>
<h1 id="3-상세-설계">3. 상세 설계</h1>
<hr />
<h2 id="32-블록-저장소-서버">3.2 블록 저장소 서버</h2>
<p>큰 파일들은 업데이트가 발생할 때 마다 전체 파일을 서버로 보내면 네트워크 대역폭을 많이 잡아먹게 된다. 이를 최적화 하는 방법으로는 두 가지 정도가 있다.</p>
<h3 id="델타-동기화">델타 동기화</h3>
<p>파일 수정시 전체 파일이 아닌 수정이 일어난 부분만 동기화 한다.</p>
<p><img alt="" src="https://velog.velcdn.com/images/limseohyeon/post/f245088c-b21d-46ac-836d-ec56c803a9a9/image.png" /></p>
<h3 id="압축">압축</h3>
<p>블록 단위로 압축해 둔다. 압축 알고리즘은 파일 유형에 따라 결정된다.</p>
<h3 id="블록-저장-서버-동작">블록 저장 서버 동작</h3>
<ol>
<li>파일을 작은 블록으로 분할한다.</li>
<li>각 블록을 압축한다.</li>
<li>클라우드 저장소로 보내기 전에 암호화 한다.</li>
<li>클라우드 저장소로 보낸다.</li>
</ol>
<p>이때, 델타 동기화를 적용하는 갱신된 부분만 동기화 한다.</p>
<h2 id="33-높은-일관성-요구사항">3.3 높은 일관성 요구사항</h2>
<p>드라이브 시스템은 파일이 단말이나 사용자에 따라 다르게 보이지 않도록 높은 일관성을 지원해야 한다.</p>
<p>강한 일관성을 달성하려면 다음 사항을 보장해야 한다.</p>
<ul>
<li>캐시에 보관된 사본과 데이터베이스에 있는 원본이 일치한다.</li>
<li>원본에 변경이 발생하면 캐시에 있는 사본을 무효화 한다.</li>
</ul>
<p>관계형 데이터베이스는 ACID로 강한 일관성을 보장하기 쉬우나 NoSQL은 그렇지 않다.</p>
<h3 id="메타데이터-데이터베이스">메타데이터 데이터베이스</h3>
<ul>
<li>user : 사용자 기본 정보</li>
<li>device : 단말 정보</li>
<li>namespace : 루트 디렉터리 정보</li>
<li>file : 파일 최신 정보</li>
<li>file_version :: 파일 갱신 이력 보관 (읽기 전용)</li>
<li>block : 파일 블록에 대한 정보 보관</li>
</ul>
<h3 id="업로드-절차">업로드 절차</h3>
<p><strong>파일 메타데이터 추가</strong></p>
<ol>
<li>클라이언트 : 요청 전송</li>
<li>메타데이터 데이터베이스 저장 후 업로드 상태 대기중으로 변경 후 알림 서비스에 새 파일 추가 통지</li>
<li>알림 서비스 : 클라이언트에 알림</li>
</ol>
<p><strong>파일 클라우드 저장소에 업로드</strong></p>
<ol>
<li>클라이언트 : 블록 저장소 서버에 파일 업로드</li>
<li>블록 저장소 : 블록 단위로 분할 - 압축 - 암호화 후 클라우드 저장소에 전송</li>
<li>클라우드 저장소 : 업로드 후 완료 콜백 호출, 콜백은 API 서버로 전송</li>
<li>메타데이터 DB의 해당 파일 상태를 완료로 변경</li>
<li>알림 서비스에 업로드 종료 통지</li>
<li>알림 서비스 : 클라이언트에 알림</li>
</ol>
<h2 id="32-다운로드-절차">3.2 다운로드 절차</h2>
<p>파일 다운로드는 파일이 추가되거나 편집 되면 자동으로 시작된다. 다른 클라이언트는 파일 변경 여부를 어떻게 감지할까?</p>
<ul>
<li>클라이언트 A가 접속 중인 경우 : 알림 서비스가 변경 여부를 알림</li>
<li>클라이언트 A가 접속 중이지 않은 경우 : 데이터는 캐시 보관</li>
</ul>
<h3 id="다운로드-동작">다운로드 동작</h3>
<ol>
<li>알림 서비스 : 클라이언트에 파일 변경 여부를 알림</li>
<li>클라이언트 : 새로운 메타데이터 요정</li>
<li>API 서버 : 새로운 메타데이터 반환</li>
<li>클라이언ㄴ트 : 새 메타데이터 받은 즉시 블록 다운로드 요청 전송</li>
<li>블록 저장소 서버 : 클라우드 저장소에서 블록 다운로드 (클라우드 저장소 블록 반환)</li>
<li>블록 저장소 서버 : 클라이언트에 블록 반환</li>
<li>클라이언트 : 블록을 사용해 파일 재구성</li>
</ol>
<h2 id="33-알림-서비스">3.3 알림 서비스</h2>
<p>파일의 일관성을 유지하기 위해 클라이언트는 로컬에서 파일이 수정됐음을 감지하면 이를 알려 충돌 가능성을 줄여야 한다. 이에 방법이 두 가지 있다.</p>
<ul>
<li>롱폴링</li>
<li>웹소켓</li>
</ul>
<p>해당 설계에서는 롱폴링을 사용할 것이다.</p>
<ul>
<li>채팅 서비스와 달리 알림 서비스는 양방향 통신이 필요하지 않다.</li>
<li>알림이 자주 발생하지 않으며 단시간에 많은 데이터를 보낼 일이 없다.</li>
</ul>
<h3 id="알림-서비스-동작">알림 서비스 동작</h3>
<ol>
<li>클라이언트는 알림 서버와 롱 폴링 연결</li>
<li>특정 파일 변경 감지 → 롱 폴링 연결 중지</li>
<li>클라이언트는 메타데이터 서버를 통해 최신 내역 다운</li>
<li>작업 종료 혹은 연결 타임아웃 시간에 도달한 경우 새로운 롱 폴링 연결</li>
</ol>
<h2 id="34-장애처리">3.4 장애처리</h2>
<p>대규모 서비스에서 발생할만한 장애와 그 해결법은 아래와 같은 것들이 있다.</p>
<ul>
<li>로드밸런서 장애 : 부 로드밸런서가 활성화되어 트래픽을 이어받는다. 이때 서로 박동 신호를 통해 모니터링한다.</li>
<li>블록 저장소 서버 장애 : 다른 서버가 미완료 상태 또는 대기 상태인 작업을 이어 받는다.</li>
<li>클라우드 저장소 장애 : S3의 경우 다중화 가능하므로 다른 지역에서 파일을 가져온다.</li>
<li>API 서버 장애 : 무상태 특징으로 트래픽을 해당 서버로 보내지 않음으로써 장애를 격리한다.</li>
<li>메타데이터 캐시 장애 : 캐시 서버도 다중화할 수 있다. 이에 다른 노드에서 데이터를 가져온다.</li>
<li>메타데이터 데이터베이스 장애<ul>
<li>주 데이터베이스 서버 장애 : 부 데이터베이스를 주 데이터베이스로 바꾸고 새로운 부 데이터베이스 서버를 생선한다.</li>
<li>부 데이터베이스 서버 장애 : 다른 부 데이터베이스 서버가 연산을 처리하도록 하고 새로운 부 데이터베이스 서버로 교체한다.</li>
</ul>
</li>
<li>알림 서비스 장애 : 한 대 서버에 장애가 발생하면 모든 사용자가 롱 폴링을 다시 만들어야 한다. 동시에 모든 사용자가 접속을 시작하는 것은 불가하므로 롱 폴링 연결 복구는 상대적으로 느릴 수 있다.</li>
<li>오프라인 사용자 백업 큐 장애 : 큐 또한 다중화해 두어야 한다. 백업 큐로 구독 관계를 재설정 한다.</li>
</ul>
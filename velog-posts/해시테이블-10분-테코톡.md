<!-- ENTRY_ID: https://velog.io/@limseohyeon/%ED%95%B4%EC%8B%9C%ED%85%8C%EC%9D%B4%EB%B8%94-10%EB%B6%84-%ED%85%8C%EC%BD%94%ED%86%A1 -->
<!-- SOURCE_TITLE: 해시테이블 - 10분 테코톡 -->

<p><img alt="" src="https://velog.velcdn.com/images/limseohyeon/post/a3fa2bf5-ddac-4e51-b77e-8197bba3c076/image.png" />
<a href="https://youtu.be/YVl2Ua3K_oM?si=Qe94eKCu6qSoWEiE">10분 테코톡 - 해시테이블</a></p>
<h1 id="1-해시테이블hashtable">1. 해시테이블(HashTable)</h1>
<hr />
<p>해시 테이블이란 key-value 형식의 데이터를 저장하는 자료구조이다.</p>
<p> <code>key</code>는 구분자로 <strong>중복을 허용하지 않지만</strong>, <code>value</code>는 <strong>중복을 허용</strong>한다.</p>
<h2 id="12-해시-테이블의-동작-과정">1.2 해시 테이블의 동작 과정</h2>
<p><strong>데이터 추가</strong></p>
<ol>
<li>key를 해시 함수에 넣어 해시값을 계산한다.</li>
<li>해시값에 해당하는 인덱스에 value를 할당한다.</li>
</ol>
<p><strong>데이터 삭제</strong></p>
<ol>
<li>key를 해시 함수에 넣어 해시값을 계산한다.</li>
<li>해시값에 해당하는 인덱스에 있는 데이터를 삭제한다.</li>
</ol>
<h2 id="13-해시-테이블-특징">1.3 해시 테이블 특징</h2>
<ul>
<li>조회/등록/수정/삭제 연산 빠름 O(1)</li>
<li>메모리 효율이 떨어짐</li>
</ul>
<h1 id="2-해시함수란">2. 해시함수란</h1>
<hr />
<p>해시함수란 <strong>고정범위</strong>의 인덱스 값을 만들어내는 <strong>단방향 암호화 함수</strong>로 해시값은 어떤 해시함수를 사용하느냐에 따라 달라진다.</p>
<p>단방향 암호화 함수이기 때문에 복호화가 불가능하다. 즉, 해시값으로 key를 추적할 수 없다.</p>
<h2 id="21-특징">2.1 특징</h2>
<ul>
<li>일관성 : 동일한 key 라면 항상 동일한 해시값을  반환함</li>
<li>균등분포 : 해시 값이 균등하게 나오도록 설계 됨</li>
<li>속도 : 연산속도 빠름</li>
</ul>
<h1 id="2-버킷">2. 버킷</h1>
<hr />
<p>해시테이블에서 실제 데이터가 저장되는 공간이다. 자료구조로는 해시값을 인덱스로하는 배열을 주로 사용한다.</p>
<h2 id="21-버킷의-크기">2.1 버킷의 크기</h2>
<p>버킷의 크기와 해시값의 크기가 동일한 것은 아니다.</p>
<p>그 예로 java에서는 4byte의 int형식의 해시값을 기본으로 생성하는데 그에 대응되는 버킷은 그렇지 않다는 것.</p>
<p>이에 해시값을 버킷배열의 크기로 나머지 연산을 수행해 나온 값을 이용해 해시값-버킷배열 간 데이터 할당을 진행한다.</p>
<p>ex) 버킷배열 크기=3, 해시값 = 0</p>
<p>0 %3 → 0 로, 해당 데이터는 버킷배열의 인덱스 0에 할당</p>
<h2 id="22-로드팩터">2.2 로드팩터</h2>
<p>로드팩터란 전체 버킷 공간에서 데이터가 실제 존재하는 공간의 크기 비율이다.</p>
<p>로드팩터가 높다 = 해시 테이블에 빈 공간이 없음 → 충돌 발생 가능성 증가 를 의미한다.</p>
<h2 id="23-리사이징">2.3 리사이징</h2>
<p>로드팩터가 일정 수준이 되었을 때 버킷 크기를 늘리는 과정을 의미한다.</p>
<h1 id="3-충돌-처리">3. 충돌 처리</h1>
<hr />
<p>충돌이란 서로 다른 key 값을 가진 데이터들이 같은 버킷 공간에 할당되는 상태를 의미한다.</p>
<h2 id="31-충돌-처리-해결-방법">3.1 충돌 처리 해결 방법</h2>
<h3 id="311-체이닝">3.1.1. 체이닝</h3>
<p>충돌이 발생한 데이터들을 연결리스트 형태로 연결해 저장하는 방법</p>
<p><strong>ex)</strong> key : A, B, C 에 충돌이 발생한 경우 이 A-B-C 와 같이 연결리스트 형태로 변경해 저장한다.</p>
<h3 id="312-개방-주소법">3.1.2 개방 주소법</h3>
<p>충돌이 발생핼을 때 조사 함수를 반복적으로 연산해 버킷의 빈 공간을 찾아내는 방법이다.</p>
<p>index2에 충돌이 발생, index5가 비어 있는 경우index5를 찾을 때까지 계속해서 조사 함수를 연산한다.  </p>
<p><strong>조사 함수 종류</strong></p>
<ul>
<li>선형 조사법: (해시값 + 충돌횟수) % 배열크기</li>
<li>이차 조사법: (해시값 + 충돌횟수^2) % 배열크기</li>
<li>이중해싱: (해시값 + (두번째 해시값)*충돌횟수) % 배열 크기</li>
</ul>